# Project Rules - Multi-API Architecture - Clean Code & Context7

## üéØ **Vis√£o Geral**
Este arquivo define as regras e boas pr√°ticas para o projeto multi-API, diferenciando entre **Business API (Java 17)** e **Legacy API (Java 8)**, seguindo princ√≠pios de Clean Code e Context7.

## üìã **Arquitetura do Projeto**

### **Estrutura Multi-API**
```
glojas-modernized/
‚îú‚îÄ‚îÄ business-api/          # Java 17 - Spring Boot 3.x - Moderno
‚îÇ   ‚îú‚îÄ‚îÄ config/           # Configura√ß√µes avan√ßadas
‚îÇ   ‚îú‚îÄ‚îÄ controller/       # Controllers REST
‚îÇ   ‚îú‚îÄ‚îÄ dto/             # DTOs com Records e Lombok
‚îÇ   ‚îú‚îÄ‚îÄ entity/          # Entidades JPA modernas
‚îÇ   ‚îú‚îÄ‚îÄ exception/       # Exce√ß√µes customizadas
‚îÇ   ‚îú‚îÄ‚îÄ factory/         # Factories para cria√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ mapper/          # Mappers para convers√£o
‚îÇ   ‚îú‚îÄ‚îÄ repository/      # Repositories JPA
‚îÇ   ‚îî‚îÄ‚îÄ service/         # Servi√ßos de neg√≥cio
‚îú‚îÄ‚îÄ legacy-api/           # Java 8 - Spring Boot 2.x - Legacy
‚îÇ   ‚îú‚îÄ‚îÄ controller/      # Controllers REST
‚îÇ   ‚îú‚îÄ‚îÄ dto/            # DTOs com Lombok
‚îÇ   ‚îú‚îÄ‚îÄ entity/         # Entidades JPA
‚îÇ   ‚îú‚îÄ‚îÄ repository/     # Repositories JPA
‚îÇ   ‚îî‚îÄ‚îÄ service/        # Servi√ßos de acesso a dados
‚îî‚îÄ‚îÄ frontend/            # React/Node.js
```

## üîß **Tecnologias por API**

### **Business API (Java 17)**
- **Java**: 17+
- **Spring Boot**: 3.x
- **Spring Security**: JWT + OAuth2
- **Spring Data JPA**: 3.x
- **Bean Validation**: 3.x
- **Flyway**: Migra√ß√µes
- **Lombok**: Redu√ß√£o de boilerplate
- **Records**: DTOs simples (‚â§5 campos)
- **Sealed Classes**: Hierarquias fechadas
- **Pattern Matching**: Switch expressions
- **Text Blocks**: Strings multi-linha

### **Legacy API (Java 8)**
- **Java**: 8
- **Spring Boot**: 2.7.x
- **Spring Security**: B√°sico
- **Spring Data JPA**: 2.x
- **Bean Validation**: 2.x
- **Lombok**: Redu√ß√£o de boilerplate
- **Classes Tradicionais**: DTOs complexos
- **Streams API**: Processamento de dados
- **Optional**: Tratamento de nulos
- **Lambda Expressions**: Programa√ß√£o funcional

## üìù **Padr√µes de C√≥digo por API**

### **1. DTOs - Abordagem Diferenciada**

#### **Business API (Java 17) - Records para Simples**
```java
// DTOs simples (‚â§5 campos) - Usar Records
public record UserSummaryDto(
    Long id,
    String name,
    String email,
    boolean isActive
) {
    public UserSummaryDto {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Nome n√£o pode ser nulo ou vazio");
        }
        if (email == null || !email.contains("@")) {
            throw new IllegalArgumentException("Email deve ser v√°lido");
        }
    }
}

// DTOs complexos (>5 campos) - Usar Lombok
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserDetailDto {
    
    @NotBlank(message = "Nome √© obrigat√≥rio")
    @Size(min = 2, max = 100, message = "Nome deve ter entre 2 e 100 caracteres")
    private String name;
    
    @NotBlank(message = "Email √© obrigat√≥rio")
    @Email(message = "Email deve ser v√°lido")
    private String email;
    
    @Pattern(regexp = "^[a-zA-Z0-9_]+$", message = "Username deve conter apenas letras, n√∫meros e underscore")
    private String username;
    
    private Set<RoleDto> roles;
    private LocalDateTime createdAt;
    private LocalDateTime lastLoginAt;
    
    @Override
    public String toString() {
        return "UserDetailDto{" +
                "name='" + name + '\'' +
                ", email='[PROTECTED]'" +
                ", username='" + username + '\'' +
                ", roles=" + roles +
                '}';
    }
}
```

#### **Legacy API (Java 8) - Lombok para Todos**
```java
// Todos os DTOs usam Lombok (Java 8 n√£o tem Records)
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ProductRegisteredDTO {
    
    /**
     * C√≥digo do produto
     */
    private Long codigo;
    
    /**
     * Descri√ß√£o da se√ß√£o
     */
    private String secao;
    
    /**
     * Descri√ß√£o do grupo
     */
    private String grupo;
    
    /**
     * Descri√ß√£o do subgrupo
     */
    private String subgrupo;
    
    /**
     * Descri√ß√£o da marca
     */
    private String marca;
    
    /**
     * C√≥digo do part number
     */
    private String partNumberCodigo;
    
    /**
     * C√≥digo PLU da refer√™ncia
     */
    private String refplu;
    
    /**
     * Descri√ß√£o do produto
     */
    private String descricao;
    
    /**
     * C√≥digo NCM do produto
     */
    private String ncm;
}
```

### **2. Entidades JPA**

#### **Business API (Java 17) - Moderno**
```java
@Entity
@Table(name = "users")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, unique = true, length = 50)
    private String username;
    
    @Column(nullable = false, unique = true, length = 100)
    private String email;
    
    @Column(nullable = false)
    private String password;
    
    @Column(name = "is_active")
    @Builder.Default
    private boolean isActive = true;
    
    @Column(name = "is_not_locked")
    @Builder.Default
    private boolean isNotLocked = true;
    
    @Column(name = "join_date")
    @Builder.Default
    private LocalDateTime joinDate = LocalDateTime.now();
    
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set<Role> roles = new HashSet<>();
    
    // M√©todos de neg√≥cio
    public void addRole(Role role) {
        this.roles.add(role);
        role.getUsers().add(this);
    }
    
    public void removeRole(Role role) {
        this.roles.remove(role);
        role.getUsers().remove(this);
    }
    
    public boolean hasRole(String roleName) {
        return roles.stream()
                .anyMatch(role -> role.getName().equals(roleName));
    }
}
```

#### **Legacy API (Java 8) - Compat√≠vel**
```java
@Entity
@Table(name = "products")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Product {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "codigo", nullable = false, unique = true)
    private String codigo;
    
    @Column(name = "descricao", nullable = false)
    private String descricao;
    
    @Column(name = "secao")
    private String secao;
    
    @Column(name = "grupo")
    private String grupo;
    
    @Column(name = "marca")
    private String marca;
    
    @Column(name = "ncm")
    private String ncm;
    
    @Column(name = "is_active")
    @Builder.Default
    private boolean isActive = true;
    
    // M√©todos de neg√≥cio simples
    public boolean isValid() {
        return codigo != null && !codigo.trim().isEmpty() &&
               descricao != null && !descricao.trim().isEmpty();
    }
}
```

### **3. Servi√ßos - Clean Code**

#### **Business API (Java 17) - Separa√ß√£o Avan√ßada**
```java
@Slf4j
@Service
@RequiredArgsConstructor
public class UserService {
    
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final UserMapper userMapper;
    private final UserValidator userValidator;
    
    /**
     * Cria um novo usu√°rio no sistema.
     * 
     * @param request Dados do usu√°rio a ser criado
     * @return Dados do usu√°rio criado
     * @throws UserAlreadyExistsException se o username ou email j√° existirem
     */
    public CreateUserResponse createUser(CreateUserRequest request) {
        log.info("Criando usu√°rio: {}", request.username());
        
        // 1. Valida√ß√£o
        userValidator.validateCreateRequest(request);
        
        // 2. Verifica√ß√£o de exist√™ncia
        if (userRepository.existsByUsername(request.username())) {
            throw new UserAlreadyExistsException("username", request.username());
        }
        if (userRepository.existsByEmail(request.email())) {
            throw new UserAlreadyExistsException("email", request.email());
        }
        
        // 3. Cria√ß√£o da entidade
        User user = userMapper.toEntity(request);
        user.setPassword(passwordEncoder.encode(request.password()));
        
        // 4. Persist√™ncia
        User savedUser = userRepository.save(user);
        
        log.info("Usu√°rio criado com sucesso: {}", savedUser.getId());
        
        // 5. Mapeamento para resposta
        return userMapper.toCreateResponse(savedUser);
    }
    
    /**
     * Busca usu√°rios com filtros e pagina√ß√£o.
     */
    public Page<UserSummaryDto> findUsers(UserSearchRequest request) {
        log.debug("Buscando usu√°rios com filtros: {}", request);
        
        Pageable pageable = PageRequest.of(
            request.page(), 
            request.size(), 
            Sort.by(Sort.Direction.fromString(request.sortDir()), request.sortBy())
        );
        
        Page<User> users = userRepository.findByFilters(
            request.name(),
            request.email(),
            request.isActive(),
            pageable
        );
        
        return users.map(userMapper::toSummaryDto);
    }
}
```

#### **Legacy API (Java 8) - Foco em Acesso a Dados**
```java
@Slf4j
@Service
@RequiredArgsConstructor
public class ProductService {
    
    private final ProductRepository productRepository;
    
    /**
     * Busca produtos cadastrados com filtros, pagina√ß√£o e ordena√ß√£o
     */
    public Page<ProductRegisteredDTO> findProductsWithFilters(
            String secao, String grupo, String marca, String descricao,
            int page, int size, String sortBy, String sortDir) {
        
        log.debug("Buscando produtos com filtros: secao={}, grupo={}, marca={}, descricao={}, page={}, size={}, sortBy={}, sortDir={}",
                secao, grupo, marca, descricao, page, size, sortBy, sortDir);
        
        // 1. Valida√ß√£o
        validatePaginationParameters(page, size);
        validateSortParameters(sortBy, sortDir);
        
        // 2. Configura√ß√£o
        Pageable pageable = createPageable(page, size, sortBy, sortDir);
        ProductFilters filters = createProductFilters(secao, grupo, marca, descricao);
        
        // 3. Busca de dados
        List<Object[]> rows = fetchProductData(filters, pageable);
        Long totalElements = countProductData(filters);
        
        // 4. Convers√£o
        List<ProductRegisteredDTO> dtos = convertToProductDTOs(rows);
        
        log.debug("Produtos encontrados: {} de {}", dtos.size(), totalElements);
        
        return new PageImpl<>(dtos, pageable, totalElements);
    }
    
    /**
     * Conta o total de produtos cadastrados
     */
    public long countTotalProducts() {
        log.debug("Contando total de produtos cadastrados");
        long count = productRepository.countTotalProducts();
        log.debug("Total de produtos: {}", count);
        return count;
    }
    
    // M√©todos privados para valida√ß√£o, configura√ß√£o e convers√£o...
}
```

### **4. Controllers REST**

#### **Business API (Java 17) - Moderno**
```java
@RestController
@RequestMapping("/api/v1/users")
@RequiredArgsConstructor
@Validated
public class UserController {
    
    private final UserService userService;
    
    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    @PreAuthorize("hasRole('ADMIN')")
    public CreateUserResponse createUser(@Valid @RequestBody CreateUserRequest request) {
        return userService.createUser(request);
    }
    
    @GetMapping
    @PreAuthorize("hasRole('ADMIN') or hasRole('USER')")
    public Page<UserSummaryDto> getUsers(
            @RequestParam(required = false) String name,
            @RequestParam(required = false) String email,
            @RequestParam(required = false) Boolean isActive,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(defaultValue = "id") String sortBy,
            @RequestParam(defaultValue = "asc") String sortDir) {
        
        UserSearchRequest request = new UserSearchRequest(name, email, isActive, page, size, sortBy, sortDir);
        return userService.findUsers(request);
    }
    
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or #id == authentication.principal.id")
    public UserDetailDto getUser(@PathVariable Long id) {
        return userService.findById(id);
    }
    
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN') or #id == authentication.principal.id")
    public UpdateUserResponse updateUser(
            @PathVariable Long id,
            @Valid @RequestBody UpdateUserRequest request) {
        return userService.updateUser(id, request);
    }
    
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
    }
}
```

#### **Legacy API (Java 8) - Simples**
```java
@RestController
@RequestMapping("/products")
@RequiredArgsConstructor
public class ProductController {
    
    private final ProductControllerService productControllerService;
    
    @GetMapping("/registered")
    public ResponseEntity<ProductPageResponse> getRegisteredProducts(
            @RequestParam(required = false) String secao,
            @RequestParam(required = false) String grupo,
            @RequestParam(required = false) String marca,
            @RequestParam(required = false) String descricao,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size,
            @RequestParam(defaultValue = "codigo") String sortBy,
            @RequestParam(defaultValue = "asc") String sortDir) {
        
        ProductPageResponse response = productControllerService.getRegisteredProducts(
            secao, grupo, marca, descricao, page, size, sortBy, sortDir
        );
        
        return ResponseEntity.ok(response);
    }
    
    @GetMapping("/test-connection")
    public ResponseEntity<ProductConnectionResponse> testConnection() {
        ProductConnectionResponse response = productControllerService.testConnection();
        
        if ("ERROR".equals(response.getStatus())) {
            return ResponseEntity.status(500).body(response);
        }
        
        return ResponseEntity.ok(response);
    }
}
```

### **5. Repositories**

#### **Business API (Java 17) - Avan√ßado**
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    Optional<User> findByUsername(String username);
    Optional<User> findByEmail(String email);
    boolean existsByUsername(String username);
    boolean existsByEmail(String email);
    
    @Query("SELECT u FROM User u WHERE u.isActive = true")
    List<User> findAllActiveUsers();
    
    @Query("SELECT u FROM User u WHERE " +
           "(:name IS NULL OR LOWER(u.name) LIKE LOWER(CONCAT('%', :name, '%'))) AND " +
           "(:email IS NULL OR LOWER(u.email) LIKE LOWER(CONCAT('%', :email, '%'))) AND " +
           "(:isActive IS NULL OR u.isActive = :isActive)")
    Page<User> findByFilters(
        @Param("name") String name,
        @Param("email") String email,
        @Param("isActive") Boolean isActive,
        Pageable pageable
    );
    
    @Query("SELECT COUNT(u) FROM User u WHERE u.isActive = true")
    long countActiveUsers();
}
```

#### **Legacy API (Java 8) - SQL Nativo**
```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    @Query(value = "SELECT p.codigo, p.secao, p.grupo, p.subgrupo, p.marca, " +
                   "p.part_number_codigo, p.refplu, p.descricao, p.ncm " +
                   "FROM products p " +
                   "WHERE (:secao IS NULL OR p.secao LIKE :secaoFilter) " +
                   "AND (:grupo IS NULL OR p.grupo LIKE :grupoFilter) " +
                   "AND (:marca IS NULL OR p.marca LIKE :marcaFilter) " +
                   "AND (:descricao IS NULL OR p.descricao LIKE :descricaoFilter) " +
                   "ORDER BY " +
                   "CASE WHEN :sortBy = 'codigo' THEN p.codigo END " +
                   "CASE WHEN :sortBy = 'descricao' THEN p.descricao END " +
                   "CASE WHEN :sortBy = 'marca' THEN p.marca END " +
                   "OFFSET :offset ROWS FETCH NEXT :size ROWS ONLY",
           nativeQuery = true)
    List<Object[]> findProductsWithFilters(
        @Param("secao") String secao,
        @Param("grupo") String grupo,
        @Param("marca") String marca,
        @Param("descricao") String descricao,
        @Param("secaoFilter") String secaoFilter,
        @Param("grupoFilter") String grupoFilter,
        @Param("marcaFilter") String marcaFilter,
        @Param("descricaoFilter") String descricaoFilter,
        @Param("sortBy") String sortBy,
        @Param("offset") int offset,
        @Param("size") int size
    );
    
    @Query(value = "SELECT COUNT(*) FROM products p " +
                   "WHERE (:secao IS NULL OR p.secao LIKE :secaoFilter) " +
                   "AND (:grupo IS NULL OR p.grupo LIKE :grupoFilter) " +
                   "AND (:marca IS NULL OR p.marca LIKE :marcaFilter) " +
                   "AND (:descricao IS NULL OR p.descricao LIKE :descricaoFilter)",
           nativeQuery = true)
    Long countProductsWithFilters(
        @Param("secao") String secao,
        @Param("grupo") String grupo,
        @Param("marca") String marca,
        @Param("descricao") String descricao,
        @Param("secaoFilter") String secaoFilter,
        @Param("grupoFilter") String grupoFilter,
        @Param("marcaFilter") String marcaFilter,
        @Param("descricaoFilter") String descricaoFilter
    );
    
    @Query(value = "SELECT COUNT(*) FROM products", nativeQuery = true)
    long countTotalProducts();
}
```

## üß™ **Testes por API**

### **Business API (Java 17) - Testes Avan√ßados**
```java
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    @Mock
    private PasswordEncoder passwordEncoder;
    
    @Mock
    private UserMapper userMapper;
    
    @Mock
    private UserValidator userValidator;
    
    @InjectMocks
    private UserService userService;
    
    @Test
    void shouldCreateUserSuccessfully() {
        // Given
        CreateUserRequest request = new CreateUserRequest(
            "john.doe", "john@example.com", "password123", "John Doe"
        );
        
        User user = User.builder()
            .id(1L)
            .username("john.doe")
            .email("john@example.com")
            .name("John Doe")
            .build();
        
        CreateUserResponse expectedResponse = new CreateUserResponse(
            1L, "john.doe", "john@example.com", "John Doe"
        );
        
        // When
        when(userValidator.validateCreateRequest(request)).thenReturn(true);
        when(userRepository.existsByUsername("john.doe")).thenReturn(false);
        when(userRepository.existsByEmail("john@example.com")).thenReturn(false);
        when(userMapper.toEntity(request)).thenReturn(user);
        when(passwordEncoder.encode("password123")).thenReturn("encodedPassword");
        when(userRepository.save(any(User.class))).thenReturn(user);
        when(userMapper.toCreateResponse(user)).thenReturn(expectedResponse);
        
        CreateUserResponse response = userService.createUser(request);
        
        // Then
        assertThat(response).isNotNull();
        assertThat(response.id()).isEqualTo(1L);
        assertThat(response.username()).isEqualTo("john.doe");
        assertThat(response.email()).isEqualTo("john@example.com");
        
        verify(userValidator).validateCreateRequest(request);
        verify(userRepository).existsByUsername("john.doe");
        verify(userRepository).existsByEmail("john@example.com");
        verify(userMapper).toEntity(request);
        verify(passwordEncoder).encode("password123");
        verify(userRepository).save(any(User.class));
        verify(userMapper).toCreateResponse(user);
    }
    
    @Test
    void shouldThrowExceptionWhenUsernameAlreadyExists() {
        // Given
        CreateUserRequest request = new CreateUserRequest(
            "john.doe", "john@example.com", "password123", "John Doe"
        );
        
        // When
        when(userValidator.validateCreateRequest(request)).thenReturn(true);
        when(userRepository.existsByUsername("john.doe")).thenReturn(true);
        
        // Then
        assertThatThrownBy(() -> userService.createUser(request))
            .isInstanceOf(UserAlreadyExistsException.class)
            .hasMessage("Usu√°rio com username 'john.doe' j√° existe");
        
        verify(userRepository).existsByUsername("john.doe");
        verify(userRepository, never()).save(any(User.class));
    }
}
```

### **Legacy API (Java 8) - Testes Simples**
```java
@ExtendWith(MockitoExtension.class)
class ProductServiceTest {
    
    @Mock
    private ProductRepository productRepository;
    
    @InjectMocks
    private ProductService productService;
    
    @Test
    void shouldFindProductsWithFiltersSuccessfully() {
        // Given
        String secao = "Eletr√¥nicos";
        String grupo = "Smartphones";
        String marca = "Apple";
        String descricao = "iPhone";
        int page = 0;
        int size = 20;
        String sortBy = "codigo";
        String sortDir = "asc";
        
        List<Object[]> rows = Arrays.asList(
            createProductRow(1L, "Eletr√¥nicos", "Smartphones", "Apple", "Apple", "IPHONE13", "123", "iPhone 13", "8517.12.00"),
            createProductRow(2L, "Eletr√¥nicos", "Smartphones", "Apple", "Apple", "IPHONE14", "124", "iPhone 14", "8517.12.00")
        );
        
        when(productRepository.findProductsWithFilters(
            eq(secao), eq(grupo), eq(marca), eq(descricao),
            eq("%" + secao + "%"), eq("%" + grupo + "%"), eq("%" + marca + "%"), eq("%" + descricao + "%"),
            eq(sortBy), eq(0), eq(size)
        )).thenReturn(rows);
        
        when(productRepository.countProductsWithFilters(
            eq(secao), eq(grupo), eq(marca), eq(descricao),
            eq("%" + secao + "%"), eq("%" + grupo + "%"), eq("%" + marca + "%"), eq("%" + descricao + "%")
        )).thenReturn(2L);
        
        // When
        Page<ProductRegisteredDTO> result = productService.findProductsWithFilters(
            secao, grupo, marca, descricao, page, size, sortBy, sortDir
        );
        
        // Then
        assertThat(result).isNotNull();
        assertThat(result.getContent()).hasSize(2);
        assertThat(result.getTotalElements()).isEqualTo(2);
        assertThat(result.getTotalPages()).isEqualTo(1);
        assertThat(result.getNumber()).isEqualTo(0);
        assertThat(result.getSize()).isEqualTo(20);
    }
    
    private Object[] createProductRow(Long codigo, String secao, String grupo, String subgrupo, 
                                    String marca, String partNumber, String refplu, String descricao, String ncm) {
        return new Object[]{codigo, secao, grupo, subgrupo, marca, partNumber, refplu, descricao, ncm};
    }
}
```

## üé® **Nomenclatura por API**

### **Business API (Java 17)**
- **Controllers**: `*Controller`
- **Services**: `*Service`
- **Repositories**: `*Repository`
- **Entities**: Nome singular (ex: `User`, `Role`)
- **DTOs**: `*Request`, `*Response`, `*Dto`
- **Records**: `*Summary`, `*Info`, `*Basic`
- **Exceptions**: `*Exception`
- **Mappers**: `*Mapper`
- **Validators**: `*Validator`

### **Legacy API (Java 8)**
- **Controllers**: `*Controller`
- **Services**: `*Service`
- **Repositories**: `*Repository`
- **Entities**: Nome singular (ex: `Product`)
- **DTOs**: `*DTO`, `*Response`
- **Exceptions**: `*Exception`

## üìä **Valida√ß√µes**

### **Business API (Java 17) - Bean Validation Avan√ßado**
```java
public record CreateUserRequest(
    @NotBlank(message = "Username √© obrigat√≥rio")
    @Size(min = 3, max = 50, message = "Username deve ter entre 3 e 50 caracteres")
    @Pattern(regexp = "^[a-zA-Z0-9_]+$", message = "Username deve conter apenas letras, n√∫meros e underscore")
    String username,
    
    @NotBlank(message = "Email √© obrigat√≥rio")
    @Email(message = "Email deve ser v√°lido")
    @Size(max = 100, message = "Email deve ter no m√°ximo 100 caracteres")
    String email,
    
    @NotBlank(message = "Senha √© obrigat√≥ria")
    @Size(min = 8, max = 100, message = "Senha deve ter entre 8 e 100 caracteres")
    @Pattern(regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$", 
             message = "Senha deve conter pelo menos uma letra mai√∫scula, uma min√∫scula, um n√∫mero e um caractere especial")
    String password,
    
    @NotBlank(message = "Nome √© obrigat√≥rio")
    @Size(min = 2, max = 100, message = "Nome deve ter entre 2 e 100 caracteres")
    String name
) {
    public CreateUserRequest {
        Objects.requireNonNull(username, "Username n√£o pode ser nulo");
        Objects.requireNonNull(email, "Email n√£o pode ser nulo");
        Objects.requireNonNull(password, "Senha n√£o pode ser nula");
        Objects.requireNonNull(name, "Nome n√£o pode ser nulo");
    }
}
```

### **Legacy API (Java 8) - Valida√ß√£o Manual**
```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ProductSearchRequest {
    
    private String secao;
    private String grupo;
    private String marca;
    private String descricao;
    private Integer page;
    private Integer size;
    private String sortBy;
    private String sortDir;
    
    public void validate() {
        if (page != null && page < 0) {
            throw new IllegalArgumentException("N√∫mero da p√°gina deve ser >= 0");
        }
        if (size != null && (size <= 0 || size > 1000)) {
            throw new IllegalArgumentException("Tamanho da p√°gina deve ser entre 1 e 1000");
        }
        if (sortDir != null && !sortDir.equalsIgnoreCase("asc") && !sortDir.equalsIgnoreCase("desc")) {
            throw new IllegalArgumentException("Dire√ß√£o de ordena√ß√£o deve ser 'asc' ou 'desc'");
        }
    }
}
```

## üîç **Logging**

### **Business API (Java 17) - Estruturado**
```java
@Slf4j
@Service
public class UserService {
    
    public CreateUserResponse createUser(CreateUserRequest request) {
        log.info("Iniciando cria√ß√£o de usu√°rio: username={}, email={}", 
                request.username(), request.email());
        
        try {
            // ... l√≥gica de neg√≥cio
            
            log.info("Usu√°rio criado com sucesso: id={}, username={}", 
                    savedUser.getId(), savedUser.getUsername());
            
            return response;
        } catch (Exception e) {
            log.error("Erro ao criar usu√°rio: username={}, error={}", 
                     request.username(), e.getMessage(), e);
            throw e;
        }
    }
}
```

### **Legacy API (Java 8) - Simples**
```java
@Slf4j
@Service
public class ProductService {
    
    public Page<ProductRegisteredDTO> findProductsWithFilters(
            String secao, String grupo, String marca, String descricao,
            int page, int size, String sortBy, String sortDir) {
        
        log.debug("Buscando produtos com filtros: secao={}, grupo={}, marca={}, descricao={}, page={}, size={}, sortBy={}, sortDir={}",
                secao, grupo, marca, descricao, page, size, sortBy, sortDir);
        
        // ... l√≥gica de neg√≥cio
        
        log.debug("Produtos encontrados: {} de {}", dtos.size(), totalElements);
        
        return result;
    }
}
```

## ‚úÖ **Checklist de Qualidade por API**

### **Business API (Java 17)**
- [ ] Records para DTOs simples (‚â§5 campos)
- [ ] Lombok para DTOs complexos (>5 campos)
- [ ] Bean Validation com anota√ß√µes
- [ ] Separa√ß√£o de responsabilidades (Service, Mapper, Validator)
- [ ] Testes unit√°rios com Mockito
- [ ] Testes de integra√ß√£o com @SpringBootTest
- [ ] Logging estruturado com SLF4J
- [ ] Documenta√ß√£o JavaDoc completa
- [ ] Seguran√ßa com Spring Security
- [ ] Versionamento de API

### **Legacy API (Java 8)**
- [ ] Lombok para todos os DTOs
- [ ] Valida√ß√£o manual de par√¢metros
- [ ] Foco em acesso a dados
- [ ] Testes unit√°rios simples
- [ ] Logging b√°sico
- [ ] Documenta√ß√£o JavaDoc
- [ ] Compatibilidade com Java 8
- [ ] SQL nativo quando necess√°rio

## üéØ **M√©tricas de Qualidade**

### **Cobertura de C√≥digo**
- **Business API**: M√≠nimo 90%
- **Legacy API**: M√≠nimo 80%

### **Complexidade Ciclom√°tica**
- **M√©todos**: ‚â§ 10
- **Classes**: ‚â§ 50

### **Linhas por M√©todo**
- **Business API**: M√°ximo 15 linhas
- **Legacy API**: M√°ximo 20 linhas

### **Par√¢metros por M√©todo**
- **M√°ximo**: 5 par√¢metros
- **Ideal**: 3 par√¢metros

---

**√öltima Atualiza√ß√£o**: 28/08/2025  
**Vers√£o**: 2.0  
**Respons√°vel**: Equipe de Desenvolvimento

